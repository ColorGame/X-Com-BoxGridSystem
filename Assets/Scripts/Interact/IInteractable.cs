using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public interface IInteractable // Интерфейс взаимодействия (общий для всех взаимодействуюших объектов)
                               // Интерфейс представляет ссылочный тип, который может определять некоторый функционал - набор методов и свойств без реализации (как абстарктные методы в BaseAction).
                               // Затем этот функционал реализуют классы и структуры, которые применяют данные интерфейсы.
                               // Интерфейс это контракт с определенным функционалом. Любой class или struct расширенный этим интерфейсом , должен реализовать этот контракт. 
{
    void Interact(Action onInteractionComplete); // Взаимодействие. В аргумент предаем Делегат Взаимодействие Завершено 

}
//Конечно, это может быть альтернативой, создайте класс InteractableBase и расширьте этот класс для различных объектов. Как вы сказали, это зависит от того,
//какой общий код у вас есть между ними. Если у вас есть 10 взаимодействующих объектов, и все они используют много общего кода, то, возможно, было бы разумно сделать это,
//но если только у 2 есть дублирующий код, то, возможно, это не лучший подход.Как вы сказали, это зависит от того, какой общий код у вас есть между ними.

// Лично я стараюсь избегать использования базовых классов, насколько это возможно, потому что я нахожу, что они очень быстро создают много путаницы, поэтому я использую их очень редко.
// Интерфейс имеет для меня больше смысла, поскольку в моем дизайне я не обязательно хотел, чтобы каждый взаимодействующий объект работал одинаково.
// И если вам все еще нужен какой-то общий код между ними, вы все равно можете использовать интерфейс, а начиная с C # 8 теперь вы можете определять код по умолчанию внутри интерфейса. 
